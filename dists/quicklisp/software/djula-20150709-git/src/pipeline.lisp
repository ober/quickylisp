(in-package #:djula)

;;; The basic plan of DJULA is kind of a half-assed lexer/parser than
;;; compiles templates to functions.  I don't have the expertise to
;;; properly fix the lexing and parsing at this time, so I'm just
;;; trying to clean up and better organize the code.  Roughly, the
;;; processing stages are:

;;; 1. lex     : string      => tokens
;;; 2. parse   : tokens      => tokens/tags
;;; 3. compile : tokens/tags => functions
;;; 4. execute : functions   => string
;;; 5. filter  : string      => string

;;; The lexical analysis phase is handled via simple string search and
;;; splitting.  The parsing phase is handled by the various
;;; "processor" functions constructed using the macros below.
;;; REST-VAR is the token stream generated by the lexer.  The parser
;;; consumes tokens and produces a mix of tokens and "tags" that span
;;; multiple input tokens.  (It does not appear that nesting of tags
;;; is handled properly...)

;;; The "compiler" functions produce functions that output to a
;;; stream, looking to the dynamic variable *TEMPLATE-ARGUMENTS* for
;;; variables in the current scope.

;;; rest-var => a poorly executed stream variable
(defmacro def-token-processor (name args rest-var &body body)
  (with-unique-names (arg-list)
    `(setf (get ,name 'token-processor)
           (lambda (&rest ,arg-list)
             (destructuring-bind (,rest-var ,@args)
                 ,arg-list
               ,@body)))))

(defmacro def-unparsed-tag-processor (name args rest-var &body body)
  (with-unique-names (arg-list)
    `(setf (get ,name 'unparsed-tag-processor)
           (lambda (&rest ,arg-list)
             (destructuring-bind (,rest-var ,@args)
                 ,arg-list
               ,@body)))))

(defmacro def-tag-processor (name args rest-var &body body)
  (with-unique-names (arg-list)
    `(setf (get ,name 'tag-processor)
           (lambda (&rest ,arg-list)
             (destructuring-bind (,rest-var ,@args)
                 ,arg-list
               ,@body)))))

(defmacro def-delimited-tag (starttag endtag delimited-name)
  `(progn
     (def-tag-processor ,starttag (&rest args) unprocessed
       (multiple-value-bind (processed-clause processed-rest present-p)
           (find-end-tag ,endtag (process-tokens unprocessed))
         (unless present-p
           (template-error "Error parsing delimited tag {% ~A %}, cannot find closing tag {% ~A %}" ,starttag ,endtag))
         (process-tokens
          (cons (list* ,delimited-name args processed-clause)
                processed-rest))))
     (def-tag-compiler ,endtag (&optional argument)
       (template-error "unmatched ending tag {% ~A~@[~A~] %}" ,endtag argument))))

(defmacro def-token-compiler (name args &body body)
  (with-unique-names (arg-list)
    `(setf (get ,name 'token-compiler)
           (lambda (&rest ,arg-list)
             (destructuring-bind (,@args)
                 ,arg-list
               ,@body)))))

(defmacro def-tag-compiler (name args &body body)
  (with-unique-names (arg-list)
    `(setf (get ,name 'tag-compiler)
           (lambda (&rest ,arg-list)
             (destructuring-bind (,@args)
                 ,arg-list
               ,@body)))))

(defmacro def-filter (name args &body body)
  (with-unique-names (e msg)
    `(setf (get ,name 'filter)
           (lambda (,@args)
             (handler-case
                 (locally
                     ,@body)
               (template-error (,e)
                 (if (and *catch-template-errors-p*
			  (not *fancy-error-template-p*))
                     (princ-to-string ,e)
                     (error ,e)))
               (error (,e)
                 (let ((,msg (template-error-string* ,e "There was an error running filter ~A" ,name)))
                   (if (and *catch-template-errors-p*
			    (not *fancy-error-template-p*))
                       (princ-to-string ,msg)
                       (template-error ,msg)))))))))
