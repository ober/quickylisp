.. _manual-routes:

==========
 Маршруты
==========

Идея маршрута (англ. - route) впервые появилась в `Ruby On Rails`_ и быстро обрела популярность
в других веб-фреймворках. Также, концептуально очень близкой системой,
является `URLConf`_ в `Django`_. В последующих разработках наиболее мощной
реализацией данной идеи, вероятно, является http://routes.groovie.org/,
используемая в `Pylons`_.

Маршруты отвечают за ключевую проблему веб-разработки: сопоставление кода и URL.
Например, какой код должен отвечать за обработку запросов по адресу
"/blog/2008/01/08" или "/login"? Во многих фреймворках используется фиксированная
система диспетчеризации, например "/A/B/C" означает прочитать файл "C" в каталоге
"B", или вызвать метод "С" класса "B" в модуле "A". Это работает прекрасно до тех
пор, пока не возникает необходимости в реорганизации кода, и выясняется, что
закладки пользователей стали недействительны. Кроме того, если вы хотите
переделать адреса (например, создать раздел в подразделе), то нужно изменить
уже отлаженную логику по генерации ссылок внутри сайта.

Маршруты предлагают иной подход. Вы определяете шаблоны URL и связываете их со
своим кодом. Если вы измените свое решение по поводу конкретного URL, то просто
поменяйте шаблон URL - код по-прежнему будет работать отлично и не понадобится
менять какую-либо логику.

cl-routes
=========

Routes является ключевой концепцией `RESTAS`_, а их реализация основана на
библиотеке `cl-routes`_. 

Вот несколько возможных шаблонов URL для библиотеки `cl-routes`_
::

  /forum/:chapter/:topic/:message
  /forum/archives/:year/:month/:day
  /forum/:chapter/rss

Или с объединением строк
::

  /book/:(name)-:(chapter).html
  /:(feed).:(format)

Также поддерживаются wildcard-параметры (с тем ограничением, что такой параметр
может использоваться в шаблоне только один раз)
::

  /mydoc/*items
  /*path/rss

Большинство реализаций маршрутов (включая системы диспетчеризации `Ruby On Rails`_,
`Django`_ и `Pylons`_) хранят их в простом списке, а поиск подходящего
маршрута ведут прямым перебором до первого совпадения. Обычно, при этом
для сопоставления запроса маршруту используются регулярные выражения.
Так что, для больших сайтов, имеющих сотни (а то и тысячи) маршрутов, система
диспетчеризации запросов может оказаться узким местом, заметно снижающим общую
производительность. `cl-routes`_ компилирует все маршруты в одно дерево, ведь
поиск в дереве для большинства реальных сайтов будет заметно более эффективным,
а вместо регулярных выражений использует легковесный механизм унификации.

Кроме того, в отличие от вышеупомянутых систем, в `cl-routes`_ маршрут это не
строка, а объект класса :class:`routes:route`, для которого можно специализировать
`generic`_-метод :fun:`routes:routes:route-check-conditions`, что позволяет
осуществлять произвольные проверки при сопоставлении маршрута запросу. Данная
возможность используется в `RESTAS`_ для реализации более гибкой системы
диспетчеризации.

При задании маршрутов всегда возможны конфликты, когда один и тот же URL
соответствует нескольким шаблонам. В системах с последовательным поиском
подходящего маршрута всегда выбирается первый, `cl-routes`_ пытается выбрать
наиболее специальный, например тот, в котором больше переменных, или который
имеет более длинную статическую часть. Точного описания алгоритма разрешения
коллизий сейчас нет, но обычно с этим нет никаких проблем: поведение системы
вполне разумно и по большей части соответствует интуитивным ожиданиям.

Использование
=============

В `RESTAS`_ для создания маршрутов используется макрос :macro:`restas:define-route`,
например:

.. code-block:: common-lisp

  (restas:define-route article ("articles/:author/:item"
                                :method :get
                                :content-type "text/plain")
    (format nil "Author: ~A~Article: ~A" author item))
  
Т.е. в одном месте задаётся и шаблон URL, и обработчик, при этом в теле обработчика
сразу же доступны переменные, заданные в шаблоне URL. Вложенный обработчик,
по-умолчанию, может вернуть :hs:`string` или "octets :hs:`array`", либо целое число
(которое интерпретируется как код статуса ответа), либо :hs:`pathname` (в этом случае
вызывается :fun:`hunchentoot:handle-static-file`, которая, в отличие от систем на
базе Ruby или Python, работает достаточно быстро и реальной необходимости в
дополнительных серверах для "статики", таких как `nginx`_, обычно просто нет). 

При определении маршрута через :fun:`restas:define-route` необходимо указать
:hs:`symbol` (в приведённом примере - 'article), который будет является его именем.
Во-первых, это даёт возможность в любой момент переопределить маршрут (в том числе и
шаблон URL, лишь бы имя оставалось неизменным) простой отправкой кода в REPL (например,
с помощью M-C-x в `SLIME`_). Во-вторых, это позволяет использовать данный :hs:`symbol`
для генерации URL:

.. code-block:: common-lisp

  (restas:genurl 'article
                 :author "archimag"
                 :item "introduction-to-routes")

или для перенаправления:

.. code-block:: common-lisp

  (restas:redirect 'article
                   :author "archimag"
                   :item "introduction-to-routes")

Для одного и того же шаблона URL можно создать несколько маршрутов, накладывая на
них дополнительные ограничения.

Ограничение по типу HTTP-запроса
--------------------------------

Указывается с помощью параметра :method (по-умолчанию, :get)
макроса :macro:`restas:define-route`, например:

.. code-block:: common-lisp

  (restas:define-route view-page (":page")
     ...)
     
  (restas:define-route change-page (":page" :method :post)
     ...)

Здесь маршруты view-page и change-page обслуживают один и тоте же URL,
но view-page отвечает за обработку GET-запросов, а change-page обрабатывает
POST-запросы.

Контроль параметров URL
-----------------------

Часто необходимо накладывать ограничения на параметры шаблона URL, например,
по типу, или преобразовывать их из строкового представления в какие-либо
объекты. Для этого используется декларация :sift-variables макроса
:macro:`restas:define-route`, например:

.. code-block:: common-lisp

  (restas:define-route myroute ("/foo/:bar/:id/:page")
    (:sift-variables (bar #'check-bar)
                     (id 'integer))
    ...)

Здесь параметр id парсится как целое, bar проверяется с помощью функции
#'check-bar, а page оставляется как есть. Если функция разбора возвращает
:hs:`NIL` или генерирует ошибку, то маршрут считается не удовлетворяющим
условию и отбрасывается. В случае успеха в теле маршрута доступно уже
распарсенное значение параметра, которое возвращается указанной функцией.

.. _manual-routes-requirement:

Произвольное ограничение
------------------------

С помощью декларации :requirement макроса :macro:`restas:define-route` можно
указать произвольную функцию, которая будет вызываться при проверке маршрута.
Если она возвращает :hs:`NIL`, то маршрут считается не соответствующим запросу.

Например, в `restas-wiki`_ для обработки формы редактирования на wiki-странице
используется такой код:

.. code-block:: common-lisp

  (define-route edit-wiki-page/preview ("edit/:page"
                                        :method :post)
    (:requirement (lambda () (hunchentoot:post-parameter "preview")))
    ...)
                                        
  (define-route edit-wiki-page/cancel ("edit/:page"
                                       :method :post)
    (:requirement (lambda () (hunchentoot:post-parameter "cancel")))
    ...)

  (define-route edit-wiki-page/save ("edit/:page"
                                     :method :post)
    (:requirement (lambda () (hunchentoot:post-parameter "save")))
    ...)

Здесь маршруты edit-wiki-page/preview, edit-wiki-page/cancel и edit-wiki-page/save
отвечают за нажатие в форме кнопок Preview, Cancel и Save соответственно. 

.. _RESTAS: http://restas.lisper.ru/
.. _SLIME: http://common-lisp.net/project/slime/    
.. _cl-routes: http://github.com/archimag/cl-routes
.. _restas-wiki: http://github.com/archimag/restas-wiki
.. _generic: http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_g.htm#generic_function
.. _Ruby On Rails: http://rubyonrails.org/
.. _Pylons: http://pylonshq.com/
.. _Django: http://www.djangoproject.com/
.. _URLConf: http://docs.djangoproject.com/en/dev/topics/http/urls/
.. _nginx: http://sysoev.ru/nginx/


