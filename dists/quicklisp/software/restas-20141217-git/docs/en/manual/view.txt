.. _manual-view:

=======
 View
=======

Separation of application logic from view logic is a powerful and useful
technique, frequently used in web application development. `RESTAS`_ doesn't
force you to use such separation, but, if desired, it is provided by
the generic function

.. code-block:: common-lisp

  (defgeneric restas:render-object (drawer object)
    (:documentation "Render object via drawer"))

It is always called for processing the data returned by route handlers
(defined with :macro:`restas:define-route`). As you see here, two objects are used
for content generation: a drawer and a data object, so one can speak
about full-fledged logic and view separation, and CL
`multimethods <http://lisper.ru/pcl/object-reorientation-generic-functions>`_
make this approach quite powerful. The drawer to use is specified
in module variable :var:`*default-render-method*` and is set to nil by default.
`RESTAS`_ defines specialized `restas:render-object` methods, which
can accept the following types:

* :hs:`string` or :hs:`array` octets - data is sent to client without
  any additional processing.

* :hs:`pathname` - file is sent to client by :fun:`hunchentoot:handle-static-file`

* integer - result is treated as HTTP status and client receives corresponding
  special page.

* Report error in other cases.

Also there are methods for functions passed as drawer:

* :hs:`pathname` or integer - default handler is called (data is just sent to
  client without any processing)

* In other cases supplied function is called with funcall for data processing
  and the result is sent to client.

Apart from this, there is a specialized method for accepting arbitrary
:hs:`package` as drawer. This possibility has following basis:

* Each route has its own name and is bound by :hs:`symbol`.

* The author uses `cl-closure-template`_ for view logic almost always,
  and it compiles templates to functions and creates separate :hs:`package`
  for them.

If you follow a small agreement and give templates the same names as routes have,
then you can specify as :var:`*default-render-method*` the package containing
template functions, and `RESTAS`_ for processing a data generated by a route handler
will automatically call a template function with the same name as the route, but from
package with templates. Behold such a little magic implemented in quite simple and
understandable way. As far as technically this is just a specializer for
:fun:`restas:render-object`, you can use it in other ways, for example,
`restas-colorize`_ (pastebin analogue, you can see it in work at
http://lisper.ru/apps/format/) currently uses the following code for generating
its layout:

.. code-block:: common-lisp

  (restas:define-default-render-method (obj)
    (closure-template.standard:xhtml-strict-frame
      (list :title (getf obj :title)
            :body (restas.colorize.view:with-main-menu
                    (list :href-all (restas:genurl 'list-pastes)
                          :href-create (restas:genurl 'create-paste)
                          :body (restas:render-object (find-package '#:restas.colorize.view)
                                                      obj)))
            :css (iter (for item in '("style.css" "colorize.css"))
                       (collect (restas:genurl 'css :file item))))))

Here we defined :var:`*default-render-method*` as function (for simplicity, macro
:macro:`restas:define-default-render-method` was used) which with aid of "package
with templates" generates substantial part of page:

.. code-block:: common-lisp

  (restas:render-object (find-package '#:restas.colorize.view) obj)

and this part later is used for the generation of complete html code.

And, of course, a developer can define his own specializers of
:fun:`restas:render-object` for his own drawer type.

The other way for separation of logic and view can be used, for example,
when using :var:`*default-render-method*` doesn't fits for a particular
route, and it is :render-method parameter of :macro:`restas:define-route`.
Example:

.. code-block:: common-lisp

  (restas:define-route api-method ("/path/to/method/:(param1)/:(param2)"
                                   :content-type "application/json"
                                   :render-method #'json:encode-json)
    (list :field1 (sql-query "select ...")
          :field2 (sql-query "select ..."))))


.. _RESTAS: http://restas.lisper.ru/
.. _cl-closure-template: http://code.google.com/p/cl-closure-template/
.. _restas-colorize: http://github.com/archimag/restas-colorize
